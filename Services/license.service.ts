import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { StorageService } from './storage.service';
import { AdminService } from './admin.service';

export interface License {
  key: string;
  expirationDate?: string; // Optional - undefined means permanent license
  isActive: boolean;
  expirationDays?: number; // Optional - undefined means permanent license
  lastLoginAt?: string; // Session timeout is calculated from this timestamp
  allowedGames?: string[]; // Array of game IDs this license can access (undefined = all games)
  isAdmin?: boolean; // Flag indicating this is an admin license
}

@Injectable({
  providedIn: 'root'
})
export class LicenseService {
  private readonly STORAGE_KEY = 'rr_game_license';
  private readonly AUTH_KEY = 'rr_game_authenticated';
  private readonly SESSION_TIMEOUT_MS = 24 * 60 * 60 * 1000; // 24 hours from last login
  private isAuthenticatedSubject = new BehaviorSubject<boolean>(false);
  public isAuthenticated$ = this.isAuthenticatedSubject.asObservable();
  
  private currentLicenseSubject = new BehaviorSubject<License | null>(null);
  public currentLicense$ = this.currentLicenseSubject.asObservable();

  constructor(
    private storageService: StorageService,
    private adminService: AdminService
  ) {
    // Register this service with AdminService to avoid circular dependency
    this.adminService.setLicenseService(this);
    this.loadAuthenticationState();
  }

  /**
   * Load authentication state from storage
   */
  loadAuthenticationState(): void {
    const isAuth = localStorage.getItem(this.AUTH_KEY) === 'true';
    const licensedData = localStorage.getItem(this.STORAGE_KEY);
    
    if (isAuth && licensedData) {
      try {
        const license = JSON.parse(licensedData) as License;

        // Backward compatibility: older sessions may not have lastLoginAt
        if (license && !license.lastLoginAt) {
          license.lastLoginAt = new Date().toISOString();
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(license));
        }

        if (this.isLicenseValid(license)) {
          this.isAuthenticatedSubject.next(true);
          this.currentLicenseSubject.next(license);
          return;
        }
      } catch (e) {
        // Invalid stored license, clear it
        this.logout();
      }
    }
    
    this.isAuthenticatedSubject.next(false);
  }

  /**
   * Validate a license key and log in the user
   * @param licenseKey The temporary license key generated by an admin
   * @returns true if login successful, false otherwise
   */
  login(licenseKey: string): boolean {
    // Validate the license key against generated licenses
    const generatedLicense = this.adminService.validateLicenseKey(licenseKey);
    
    if (generatedLicense) {
      // Create the license object with expiration date
      const expirationDate = new Date();
      expirationDate.setDate(expirationDate.getDate() + (generatedLicense.expirationDays || 30));
      
      const license: License = {
        key: generatedLicense.key,
        expirationDate: expirationDate.toISOString(),
        isActive: true,
        expirationDays: generatedLicense.expirationDays || 30,
        lastLoginAt: new Date().toISOString(),
        allowedGames: generatedLicense.allowedGames
      };

      const activated = this.activateLicense(license, true);
      if (!activated) {
        return false;
      }

      // Mark as used in admin service
      this.adminService.markLicenseAsUsed(licenseKey);

      return true;
    }
    
    return false;
  }

  /**
   * Check if a license is still valid
   * @param license The license to check
   * @returns true if license is valid and not expired
   */
  private isLicenseValid(license: License): boolean {
    if (!license.isActive) {
      return false;
    }

    if (!this.isSessionValid(license.lastLoginAt)) {
      return false;
    }
    
    // If expirationDate is undefined, it''s a permanent license
    if (!license.expirationDate) {
      return true;
    }
    
    const expirationDate = new Date(license.expirationDate);
    return expirationDate > new Date();
  }

  private isSessionValid(lastLoginAt?: string): boolean {
    if (!lastLoginAt) {
      return false;
    }

    const lastLoginMs = new Date(lastLoginAt).getTime();
    if (Number.isNaN(lastLoginMs)) {
      return false;
    }

    return Date.now() - lastLoginMs <= this.SESSION_TIMEOUT_MS;
  }

  private activateLicense(license: License, persistToStorage: boolean): boolean {
    if (!this.isLicenseValid(license)) {
      return false;
    }

    if (persistToStorage) {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(license));
      localStorage.setItem(this.AUTH_KEY, 'true');
    }

    this.isAuthenticatedSubject.next(true);
    this.currentLicenseSubject.next(license);
    return true;
  }

  /**
   * Get the current authentication status
   */
  getIsAuthenticated(): boolean {
    return this.isAuthenticatedSubject.value;
  }

  /**
   * Get the current license
   */
  getCurrentLicense(): License | null {
    return this.currentLicenseSubject.value;
  }

  /**
   * Get the time remaining on the current license in days
   */
  getTimeRemaining(): number {
    const license = this.currentLicenseSubject.value;
    if (!license || !license.expirationDate) {
      // No license or permanent license (no expiration)
      return license ? 999999 : 0;
    }
    
    const expirationDate = new Date(license.expirationDate);
    const now = new Date();
    const daysRemaining = Math.ceil((expirationDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    return Math.max(0, daysRemaining);
  }

  /**
   * Logout the user and clear license
   */
  logout(): void {
    localStorage.removeItem(this.STORAGE_KEY);
    localStorage.removeItem(this.AUTH_KEY);
    this.isAuthenticatedSubject.next(false);
    this.currentLicenseSubject.next(null);
  }

  /**
   * Check if the current license has access to a specific game
   * @param gameId The game ID to check access for
   * @returns true if license has access (undefined allowedGames = access to all)
   */
  hasGameAccess(gameId: string): boolean {
    const license = this.currentLicenseSubject.value;
    
    // No license = no access
    if (!license || !license.isActive) {
      return false;
    }
    
    // License expired = no access
    if (!this.isLicenseValid(license)) {
      return false;
    }
    
    // No allowedGames restriction = access to all games
    if (!license.allowedGames || license.allowedGames.length === 0) {
      return true;
    }
    
    // Check if game is in allowed list
    return license.allowedGames.includes(gameId);
  }

  /**
   * Create a permanent admin license with all game access
   * @param username The admin username
   */
  createAdminLicense(username: string): void {
    const license: License = {
      key: `ADMIN-${username.toUpperCase()}-PERMANENT`,
      expirationDate: new Date(2099, 11, 31).toISOString(), // Permanent (far future)
      isActive: true,
      expirationDays: 999999,
      lastLoginAt: new Date().toISOString(),
      allowedGames: undefined, // Access to all games
      isAdmin: true // Mark as admin license
    };

    // Save license to storage
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(license));
    localStorage.setItem(this.AUTH_KEY, 'true');
    
    // Update state
    this.isAuthenticatedSubject.next(true);
    this.currentLicenseSubject.next(license);
  }

  /**
   * Set the current license without saving to localStorage
   * Used by AdminService when loading admin licenses from IndexedDB only
   * @param license The license to set
   */
  setCurrentLicense(license: License | any): void {
    const normalizedLicense: License = {
      key: license.key,
      expirationDate: license.expirationDate,
      expirationDays: license.expirationDays,
      isActive: license.isActive ?? license.is_active ?? false,
      lastLoginAt: license.lastLoginAt ?? license.used_at ?? license.updated_at ?? license.created_at,
      allowedGames: license.allowedGames,
      isAdmin: license.isAdmin ?? false
    };

    const activated = this.activateLicense(normalizedLicense, false);
    if (!activated) {
      this.isAuthenticatedSubject.next(false);
      this.currentLicenseSubject.next(null);
    }
  }
}
